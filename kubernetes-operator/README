
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2/build$ docker build . --tag garry1287/mysql-operator:v0.0.3
Sending build context to Docker daemon  18.43kB





Если сейчас из описания mysql убрать строчку из спецификации,
то манифест будет принят API сервером. Для того, чтобы этого
избежать, добавьте описание обязательный полей
в CustomResourceDefinition
Подсказка. Пример есть в лекции.


Объявим "обязательне" поля в спецификации, добавив дерективу spec.validation.spec.reqiored в CRD. Удалим "обязателное" поле из манивеста и попробуем применить его:

kubectl apply -f deploy/crd.yml
customresourcedefinition.apiextensions.k8s.io/mysqls.otus.homework configured

kubectl apply -f deploy/cr.yml
The MySQL "mysql-instance" is invalid: spec.storage_size: Required value



minikube start

cd build/
 2705  ls
 2706  docker build . --tag garry1287/mysql-operator:v0.0.3
 2707  cd ..
 2708  kubectl apply -f deploy/crd.yml
 2709  kubectl apply -f deploy/cr.yml



 2710  kubectl describe mysqls.otus.homework mysql-instance


 2711  kubectl apply -f kubernetes-operators/deploy/service-account.yml
 2712  kubectl apply -f deploy/service-account.yml
 2713  kubectl apply -f deploy/role.yml
 2714  kubectl apply -f deploy/role-binding.yml
 2715  kubectl apply -f deploy/deploy-operator.yml

 garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get job
NAME                         COMPLETIONS   DURATION   AGE
restore-mysql-instance-job   0/1           82s        82s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get pvc
NAME                        STATUS   VOLUME                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
backup-mysql-instance-pvc   Bound    backup-mysql-instance-pv   1Gi        RWO                           88s
mysql-instance-pvc          Bound    mysql-instance-pv          1Gi        RWO                           89s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ MYSQLPOD
^C
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ echo $MYSQLPOD
mysql-instance-f5b97ffff-4ffcq
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1146 (42S02) at line 1: Table 'otus-database.test' doesn't exist
command terminated with exit code 1
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -u root -potuspassword -e "CREATE TABLE test ( id \
>               smallint unsigned not null auto_increment, name varchar(20) not null, constraint \
>               pk_example primary key (id) );" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) \
>               VALUES ( null, 'some data' );" otus-database && 
> ^C
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) \
              VALUES ( null, 'some data' );" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) \
>               VALUES ( null, 'some data-2' );" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------------+
| id | name        |
+----+-------------+
|  1 | some data   |
|  2 | some data-2 |
+----+-------------+
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl delete mysqls.otus.homework mysql-instance
mysql.otus.homework "mysql-instance" deleted
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get pv
NAME                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM                               STORAGECLASS   REASON   AGE
backup-mysql-instance-pv   1Gi        RWO            Retain           Bound         default/backup-mysql-instance-pvc                           4m14s
mysql-instance-pv          1Gi        RWO            Retain           Terminating   default/mysql-instance-pvc                                  4m15s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get pv
NAME                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM                               STORAGECLASS   REASON   AGE
backup-mysql-instance-pv   1Gi        RWO            Retain           Bound         default/backup-mysql-instance-pvc                           4m15s
mysql-instance-pv          1Gi        RWO            Retain           Terminating   default/mysql-instance-pvc                                  4m16s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get jobs.batch
NAME                        COMPLETIONS   DURATION   AGE
backup-mysql-instance-job   1/1           5s         20s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get jobs.batch
NAME                        COMPLETIONS   DURATION   AGE
backup-mysql-instance-job   1/1           5s         21s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get jobs.batch
NAME                        COMPLETIONS   DURATION   AGE
backup-mysql-instance-job   1/1           5s         28s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl apply -f deploy/cr.yml
mysql.otus.homework/mysql-instance created
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get pv
NAME                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                               STORAGECLASS   REASON   AGE
backup-mysql-instance-pv   1Gi        RWO            Retain           Bound    default/backup-mysql-instance-pvc                           4m43s
mysql-instance-pv          1Gi        RWO            Retain           Bound    default/mysql-instance-pvc                                  4s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl get pvc
NAME                        STATUS   VOLUME                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
backup-mysql-instance-pvc   Bound    backup-mysql-instance-pv   1Gi        RWO                           4m47s
mysql-instance-pvc          Bound    mysql-instance-pv          1Gi        RWO                           8s
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$ kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
mysql: [Warning] Using a password on the command line interface can be insecure.
+----+-------------+
| id | name        |
+----+-------------+
|  1 | some data   |
|  2 | some data-2 |
+----+-------------+
garry@home-pc:~/devops_learn/kuber/kubernetes-operators2$  kubectl describe mysqls.otus.homework mysql-instance
Name:         mysql-instance
Namespace:    default
Labels:       <none>
Annotations:  kopf.zalando.org/last-handled-configuration:
                {"spec": {"database": "otus-database", "image": "mysql:5.7", "password": "otuspassword", "storage_size": "1Gi"}}
API Version:  otus.homework/v1
Kind:         MySQL
Metadata:
  Creation Timestamp:  2020-08-11T07:55:56Z
  Finalizers:
    kopf.zalando.org/KopfFinalizerMarker
  Generation:  2
  Managed Fields:
    API Version:  otus.homework/v1
    Fields Type:  FieldsV1
    fieldsV1:
      f:metadata:
        f:annotations:
          .:
          f:kubectl.kubernetes.io/last-applied-configuration:
      f:spec:
        .:
        f:database:
        f:image:
        f:password:
        f:storage_size:
    Manager:      kubectl
    Operation:    Update
    Time:         2020-08-11T07:55:56Z
    API Version:  otus.homework/v1
    Fields Type:  FieldsV1
    fieldsV1:
      f:metadata:
        f:annotations:
          f:kopf.zalando.org/last-handled-configuration:
        f:finalizers:
          .:
          v:"kopf.zalando.org/KopfFinalizerMarker":
      f:status:
        .:
        f:mysql_on_create:
          .:
          f:message:
    Manager:         kopf
    Operation:       Update
    Time:            2020-08-11T07:55:57Z
  Resource Version:  3225
  Self Link:         /apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance
  UID:               55fa6e9d-9761-43bf-8498-73d09c003a2f
Spec:
  Database:      otus-database
  Image:         mysql:5.7
  Password:      otuspassword
  storage_size:  1Gi
Status:
  mysql_on_create:
    Message:  mysql-instance created with restore job
Events:
  Type    Reason   Age   From  Message
  ----    ------   ----  ----  -------
  Normal  Logging  35s   kopf  Handler 'mysql_on_create' succeeded.
  Normal  Logging  35s   kopf  All handlers succeeded for creation.




kubectl get pods
NAME                               READY   STATUS      RESTARTS   AGE
backup-mysql-instance-job-rszjf    0/1     Completed   0          44m  - это job делающий бэкап
mysql-instance-f5b97ffff-gwbt7     1/1     Running     0          44m  - это база данных
mysql-operator-787689bd48-f7bgl    1/1     Running     0          48m  - это controller, который в ответ на создание cr создаёт pv, pvc, job
restore-mysql-instance-job-sz9dv   0/1     Completed   1          43m - это job восстанавливающий бд



--------------
https://github.com/otus-kuber-2019-12/loktionovam_platform/blob/kubernetes-operators/doc/ex-9-kubernetes-operators.md
--------------
# EX-9 Custom Resource Definitions. Operators

* [EX-9 Custom Resource Definitions. Operators](#ex-9-custom-resource-definitions-operators)
  * [EX-9.1 Что было сделано](#ex-91-%d0%a7%d1%82%d0%be-%d0%b1%d1%8b%d0%bb%d0%be-%d1%81%d0%b4%d0%b5%d0%bb%d0%b0%d0%bd%d0%be)
  * [EX-9.2 Как запустить проект](#ex-92-%d0%9a%d0%b0%d0%ba-%d0%b7%d0%b0%d0%bf%d1%83%d1%81%d1%82%d0%b8%d1%82%d1%8c-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82)
  * [EX-9.3 Как проверить проект](#ex-93-%d0%9a%d0%b0%d0%ba-%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%b8%d1%82%d1%8c-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82)
  * [EX-9.4 Как начать пользоваться проектом](#ex-94-%d0%9a%d0%b0%d0%ba-%d0%bd%d0%b0%d1%87%d0%b0%d1%82%d1%8c-%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d1%82%d1%8c%d1%81%d1%8f-%d0%bf%d1%80%d0%be%d0%b5%d0%ba%d1%82%d0%be%d0%bc)

## EX-9.1 Что было сделано

* Основное задание: создать и применить CR, CRD для mysql с валидацией схемы
* Основное задание: добавить в CRD обязательные поля
* Основное занятие: mysql оператор, управляющий persistent volume, persistent volume claim, deployment, service
* Основное занятие: деплой mysql оператора
* Задание со(*): обновление `subresource status` через оператор
* Задание со(*): смена пароля от mysql, при изменении этого параметра в описании mysql-instance

Вопрос: почему объект создался, хотя мы создали CR, до того, как запустили контроллер?

Ответ: объект создался потому что, каждый раз, когда запускается kopf based оператор он проверяет состоянием обслуживаемых их ресурсов и если состояние изменилось с момента, когда оно было последний раз обработано, то запускается новый цикл обработки, таким образом реализуется `level triggering`.

```plain
If the operator is down and not running, any changes to the objects are ignored and not handled. They will be handled when the operator starts: every time a Kopf-based operator starts, it lists all objects of the served resource kind, and checks for their state; if the state has changed since the object was last handled (no matter how long time ago), a new handling cycle starts.

Only the last state is taken into account. All the intermediate changes are accumulated and handled together. This corresponds to the Kubernetes’s concept of eventual consistency and level triggering (as opposed to edge triggering).
```

Взято отсюда: <https://kopf.readthedocs.io/en/latest/continuity/#downtime>

## EX-9.2 Как запустить проект

```bash
kubectl apply -f kubernetes-operators/deploy/crd.yml
kopf run kubernetes-operators/build/mysql_operator.py
kubectl apply -f kubernetes-operators/deploy/cr.yml
misc/scripts/fill_mysql_instance.sh
```

## EX-9.3 Как проверить проект

* Удалить запущенный проект, а затем заново создать - данные должны будут сохраниться и восстановиться через backup/restore jobs

  ```bash
  # Удаляем запущенный mysql
  delete mysqls.otus.homework mysql-instance

  # Заново создаем
  kubectl apply -f kubernetes-operators/deploy/cr.yml

  # Проверяем, что данные на месте
  export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")
  kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
  mysql: [Warning] Using a password on the command line interface can be insecure.
  +----+-------------+
  | id | name        |
  +----+-------------+
  |  1 | some data   |
  |  2 | some data-2 |
  +----+-------------+
  ```

* Проверить, что backup/restore jobs отработали без ошибок

  ```bash
  kubectl get jobs
  NAME                         COMPLETIONS   DURATION   AGE
  backup-mysql-instance-job    1/1           1s         111s
  restore-mysql-instance-job   1/1           20s        75s
  ```

* (*) Запись в `status subresources` реализуется включением `/apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance/status` эндпоинта в crd:

  ```yaml
    subresources:
    status: {}
  ```

  и обновлением статуса ресурса через вызов `patch_namespaced_custom_object_status`:

  ```python
    ...
    ...
        status = {
            "status": {
                'kopf': {
                    'message': 'mysql-instance created WITH restore-job'}}}
    ...
    ...
      api = kubernetes.client.CustomObjectsApi()
    try:
        crd_status = api.patch_namespaced_custom_object_status(group, version, namespace, plural, name, body=status)
        logging.info(crd_status)
    except kubernetes.client.rest.ApiException as e:
        print("Exception when calling CustomObjectsApi->get_namespaced_custom_object: %s\n" % e)
  ```

  Чтобы проверить, что `status subresource` обновился нужно обратиться к `/apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance/status` эндпоинту:

  ```bash
  kubectl proxy --port=8080
  curl http://localhost:8080/apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance/status 2>/dev/null | jq .status
  {
    "kopf": {
      "message": "mysql-instance created WITHOUT restore-job"
    }
  }
  ```

  Либо можно проверить вывод `kubectl describe`:

  ```bash
  kubectl describe mysqls.otus.homework mysql-instance
  Name:         mysql-instance
  Namespace:    default
  Labels:       <none>
  Annotations:  kopf.zalando.org/last-handled-configuration:
                  {"spec": {"database": "otus-database", "image": "mysql:5.7", "password": "otuspassword", "storage_size": "1Gi"}}
                kubectl.kubernetes.io/last-applied-configuration:
                  {"apiVersion":"otus.homework/v1","kind":"MySQL","metadata":{"annotations":{},"name":"mysql-instance","namespace":"default"},"spec":{"datab...
  API Version:  otus.homework/v1
  Kind:         MySQL
  Metadata:
    Creation Timestamp:  2020-03-09T15:57:40Z
    Finalizers:
      kopf.zalando.org/KopfFinalizerMarker
    Generation:        1
    Resource Version:  174341
    Self Link:         /apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance
    UID:               0a69a0e9-b820-4f20-8fe8-585fa638b624
  Spec:
    Database:      otus-database
    Image:         mysql:5.7
    Password:      otuspassword
    storage_size:  1Gi
  Status:
    Kopf:
      Message:  mysql-instance created WITHOUT restore-job
  Events:
    Type    Reason   Age   From  Message
    ----    ------   ----  ----  -------
    Normal  Logging  16m   kopf  All handlers succeeded for creation.
    Normal  Logging  16m   kopf  Handler 'mysql_on_create' succeeded.

  ```

* (*) Автоматическая смена пароля реализуется в `@kopf.on.update`, аналогично `@kopf.on.delete`, причем старый пароль мы можем узнать из аннотации `kopf.zalando.org/last-handled-configuration`:

  ```bash
  # Меняем пароль с 'otuspassword' на 'newpassword'
  kubectl apply -f kubernetes-operators/deploy/cr-passwd.yml
  ```

  ```bash
  # В логах видим, что событие обработано
  [2020-03-05 23:13:57,381] root                 [INFO    ] Old password: 'otuspassword'
  [2020-03-05 23:13:57,381] root                 [INFO    ] New password: 'newpassword'
  [2020-03-05 23:13:57,381] root                 [INFO    ] otus-database
  [2020-03-05 23:13:57,388] root                 [INFO    ] {'apiVersion': 'batch/v1', 'kind': 'Job', 'metadata': {'namespace': 'default', 'name': 'passwd-mysql-instance-job'}, 'spec': {'template': {'metadata': {'name': 'passwd-mysql-instance-job'}, 'spec': {'restartPolicy': 'OnFailure', 'containers': [{'name': 'passwd-mysql-instance', 'image': 'mysql:5.7', 'imagePullPolicy': 'IfNotPresent', 'command': ['/bin/sh', '-c', 'mysql -u root -h mysql-instance -potuspassword -e "UPDATE mysql.user SET authentication_string=PASSWORD(\'newpassword\') WHERE User=\'root\'; FLUSH PRIVILEGES;";']}]}}}}
  job with passwd-mysql-instance-job  found,wait untill end
  job with passwd-mysql-instance-job  found,wait untill end
  job with passwd-mysql-instance-job  success
  [2020-03-05 23:13:59,445] kopf.objects         [INFO    ] [default/mysql-instance] Handler 'update_object_password' succeeded.
  [2020-03-05 23:13:59,445] kopf.objects         [INFO    ] [default/mysql-instance] All handlers succeeded for update.
  ```

  ```bash
  # Подключаемся с новым паролем
  kubectl exec -ti mysql-instance-6c76bcf945-vngx8 -- mysql -u root -pnewpassword -e 'show databases;'
  mysql: [Warning] Using a password on the command line interface can be insecure.
  +--------------------+
  | Database           |
  +--------------------+
  | information_schema |
  | mysql              |
  | otus-database      |
  | performance_schema |
  | sys                |
  +--------------------+

  ```

## EX-9.4 Как начать пользоваться проектом











-------------------------
https://github.com/otus-kuber-2019-12/gidmaster_platform/blob/master/kubernetes-operators/README.md

--------------------------
# Домашнее задание 7

[Содержание](../README.md)

*NB: Использован дистрибутив `Ubuntu 18.04` с предустановленным с предустановленным `Docker` `minikube` и `VirtualBox` ПО.*

1. Custom Resource:

    Поднимем кластер `minikube`

    ```bash
    minikube start  
    ```

    Создадим Custom resource мафнифест `kubernetes-operators\deploy\cr.yml` и попробуем применить его:

    ```bash
    kubectl apply -f deploy/cr.yml

    error: unable to recognize "deploy/cr.yml": no matches for kind "MySQL" in version "otus.homework/v1"
    ```

    Ошибка связана с отсутсвием объектов типа MySQL в API kubernetes. Нам необходимо определить наш custom resorce. Для этого мы создадим Custom Resouce Definition (CRD).

2. Custom Resouce Definition:

    Создадим Custom resource definition мафнифест `kubernetes-operators\deploy\crd.yml` и попробуем применить его:

    ```bash
    kubectl apply -f deploy/crd.yml
    ```

3. Создаем CRD и CR:

    Теперь попробуем применить наш манифест с custom resource:

    ```bash
    kubectl apply -f deploy/cr.yml
    ```

    Успешно!

4. Взаимодействие с объектами CR CRD

    Посмотрим информацию о нём:

    ```bash
    kubectl get crd
    NAME                   CREATED AT
    mysqls.otus.homework   2020-01-29T20:02:07Z

    kubectl get mysqls.otus.homework
    NAME             AGE
    mysql-instance   88s

    kubectl describe mysqls.otus.homework mysql-instance
    Name:         mysql-instance
    Namespace:    default
    Labels:       <none>
    Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                    {"apiVersion":"otus.homework/v1","kind":"MySQL","metadata":{"annotations":{},"name":"mysql-instance","namespace":"default"},"spec":{"datab...
    API Version:  otus.homework/v1
    Kind:         MySQL
    Metadata:
    Creation Timestamp:  2020-01-29T20:03:17Z
    Generation:          1
    Resource Version:    2013
    Self Link:           /apis/otus.homework/v1/namespaces/default/mysqls/mysql-instance
    UID:                 6ed0da68-09d8-4a75-8f77-b5d5f16839ec
    Spec:
    Database:      otus-database
    Image:         mysql:5.7
    Password:      otuspassword
    storage_size:  1Gi
    usless_data:     useless info
    Events:          <none>
    ```

5. Validation:

    Добавим Validation в спецификацию CDR м попробуем опять применить манифесты crd.yml и cr.yml:

    ```bash
    kubectl delete mysqls.otus.homework mysql-instance
    kubectl apply -f deploy/crd.yml
    kubectl apply -f deploy/cr.yml
    ```

    Объявим "обязательне" поля в спецификации, добавив дерективу `spec.validation.spec.reqiored` в CRD. Удалим "обязателное" поле из манивеста и попробуем применить его:

    ```basj
    kubectl apply -f deploy/crd.yml
    customresourcedefinition.apiextensions.k8s.io/mysqls.otus.homework configured

    kubectl apply -f deploy/cr.yml
    The MySQL "mysql-instance" is invalid: spec.storage_size: Required value
    ```

    Отлично. Работает.

6. Операторы:

    Оператор включает в себя CRD и custom controller. CustomResourceDefinition у нас уже есть приступим к конроллеру. Полное описание кода есть в домашнем задании. Здесь я не буду приводить код. его можно поосмотреть в репозитории.

    *NB: Используемый фреймфорк `kopf` совместим с версией `python>=3.7`.*

    на первом этапе мы только сделаем [функцию](https://gist.githubusercontent.com/Evgenikk/581fa5bba6d924a3438be1e3d31aa468/raw/c7c0b8882550ab54d981a4941959276802fe0233/controller-1.py) для создания объекта `mqsql`. Попробуем его запустить.

    ```bash
    cd kubernetes-operators/build
    kopf run msql-operator.py
    ```

    Получим:

    ```bash
    [2020-02-01 22:55:03,165] kopf.reactor.activit [INFO    ] Initial authentication has been initiated.
    [2020-02-01 22:55:03,197] kopf.activities.auth [INFO    ] Handler 'login_via_pykube' succeeded.
    [2020-02-01 22:55:03,239] kopf.activities.auth [INFO    ] Handler 'login_via_client' succeeded.
    [2020-02-01 22:55:03,240] kopf.reactor.activit [INFO    ] Initial authentication has finished.
    [2020-02-01 22:55:03,296] kopf.engines.peering [WARNING ] Default peering object not found, falling back to the standalone mode.
    mysql-operator.py:9: YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details.
    json_manifest = yaml.load(yaml_manifest)
    [2020-02-01 22:55:03,827] kopf.objects         [INFO    ] [default/mysql-instance] Handler 'mysql_on_create' succeeded.
    [2020-02-01 22:55:03,828] kopf.objects         [INFO    ] [default/mysql-instance] All handlers succeeded for creation.
    [2020-02-01 23:18:46,940] kopf.reactor.running [INFO    ] Signal SIGINT is received. Operator is stopping.
    ```

    **Вопрос: почему объект создался, хотя мы создали CR, до того, как запустили контроллер?**
    Запись о CustomResource  попала в etcd и информация о ней может быть получена через kube-apiserver. Когда появляется новый ресурс, его обнаруживает контроллер mysql-operator, в задачи которого входит отслеживание изменений среди соответствующих записей пкесурсов (MySql). В нашем случае контроллер регистрирует специальный callback для событий создания через информатор. Этот обработчик будет вызван, когда mysql-operator впервые станет доступным, и начнёт свою работу с добавления объекта во внутреннюю очередь. К тому времени, когда он дойдёт до обработки этого объекта, контроллер проинспектирует и поймёт, что нет связанных с ним записей pv, pvc, service, deployment и подов. Эту информацию он получает, опрашивая kube-apiserver по label selectors. Важно заметить, что этот процесс синхронизации ничего не знает о состоянии (является state agnostic): он проверяет новые записи точно так же, как и уже существующие. А значит не важно когда контроллер был запущен, он запросит и обработает все записи о ресурсах, за кторые он отвечает и только для тех которые ещё "не обработаны" юужут созданы соответствующие ресурсы.

    Т.к. мы описали только логику создания ресурса, но не его удаления. комманда `kubectl delete mysqls.otus.homework mysql-instance` ничего не сделает. Удалим ресурасы в ручную:

    ```bash
    kubectl delete mysqls.otus.homework mysql-instance
    kubectl delete deployments.apps mysql-instance
    kubectl delete pvc mysql-instance-pvc
    kubectl delete pv mysql-instance-pv
    kubectl delete svc mysql-instance
    ```

    Добавим обработку удаления объектов в наш код. [пример](https://gist.githubusercontent.com/Evgenikk/581fa5bba6d924a3438be1e3d31aa468/raw/8308e18203e191d0318f2f6d4ec6459b27e1b56e/controller-2.py)

    Создадим наш ресурс заново, запустим контроллер у попробуем его удалить.

    ```bash
    kopf run mysql-operator.py
    ```

    ```bash
    kubectl apply -f deploy/cr.yml
    kubectl delete -f deploy/cr.yml
    kubectl get all
    kubectl get pvc
    kubectl get pv
    ```

    Реализуем создание и воссатновление из бекапов нашего ресурса. [пример](https://gist.github.com/Evgenikk/581fa5bba6d924a3438be1e3d31aa468/raw/8a3ef47ed87128867496fbb45ae4fd483b2549db/controller-4.py)

    *NB: в коде из примера не хватает строчки `kopf.append_owner_reference(restore_job, owner=body)`*

    Проверяем как это всё работает

    ```bash
    kopf run mysql-operator.py
    ```

    ```bash
    kubectl apply -f deploy/cr.yml
    kubectl get pvc
    export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")

    kubectl exec -it $MYSQLPOD -- mysql -u root -potuspassword -e "CREATE TABLE test ( id smallint unsigned not null auto_increment, name varchar(20) not null, constraint pk_example primary key (id) );" otus-database

    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) VALUES ( null, 'some data' );" otus-database
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) VALUES ( null, 'some data-2' );" otus-database
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
    +----+-------------+
    | id | name        |
    +----+-------------+
    |  1 | some data   |
    |  2 | some data-2 |
    +----+-------------+
    ```

    Удалим mysql-instance:

    ```bash
    kubectl delete mysqls.otus.homework mysql-instance
    kubectl get pv
    kubectl get jobs.batch
    ```

    Создадим новцй копию нашего инстанса и проверим получилось ли восстановится из backup:

    ```bash
    kubectl apply -f deploy/cr.yml

    export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
    +----+-------------+
    | id | name        |
    +----+-------------+
    |  1 | some data   |
    |  2 | some data-2 |
    +----+-------------+
    ```

    Наш самописный контроллер работает! Теперь обернём его в Docker контейнер запушим в репозиторий.

    ```bash
    cd build
    docker build -t gidmaster/mysql-operator:v0.1 .
    docker push  gidmaster/mysql-operator:v0.1
    ```

    Создадим роль, sa и deployment и наконец загрузим наш контроллер в кластер:

    ```bash
    kubectl apply -f /deploy
    ```

    и выполним туже проверку, что мы сделали ранее:

    ```bash
    kubectl apply -f deploy/cr.yml
    kubectl get pvc
    export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")

    kubectl exec -it $MYSQLPOD -- mysql -u root -potuspassword -e "CREATE TABLE test ( id smallint unsigned not null auto_increment, name varchar(20) not null, constraint pk_example primary key (id) );" otus-database

    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) VALUES ( null, 'some data' );" otus-database
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "INSERT INTO test ( id, name ) VALUES ( null, 'some data-2' );" otus-database
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
    +----+-------------+
    | id | name        |
    +----+-------------+
    |  1 | some data   |
    |  2 | some data-2 |
    +----+-------------+
    ```

    Удалим mysql-instance:

    ```bash
    kubectl delete mysqls.otus.homework mysql-instance
    kubectl get pv
    kubectl get jobs.batch
    ```

    Создадим новцй копию нашего инстанса и проверим получилось ли восстановится из backup:

    ```bash
    kubectl apply -f deploy/cr.yml

    export MYSQLPOD=$(kubectl get pods -l app=mysql-instance -o jsonpath="{.items[*].metadata.name}")
    kubectl exec -it $MYSQLPOD -- mysql -potuspassword -e "select * from test;" otus-database
    +----+-------------+
    | id | name        |
    +----+-------------+
    |  1 | some data   |
    |  2 | some data-2 |
    +----+-------------+
    ```

[Назад к содержанию](../README.md)
